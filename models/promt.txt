this is question model
//model/question.js
const { client } = require("../db/index.js");

// -- Create Question Table
const createQuestionTableQuery = `
CREATE TABLE IF NOT EXISTS question (
    id SERIAL PRIMARY KEY,
    question_text VARCHAR NOT NULL,
    question_type VARCHAR CHECK (question_type IN ('MCQS', 'true_false')),
    difficulty_level VARCHAR CHECK (difficulty_level IN ('easy', 'medium', 'hard')),
    categories INTEGER[],
    created_by INT,
    is_active BOOLEAN DEFAULT TRUE,
    is_custom BOOLEAN DEFAULT FALSE,
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (created_by) REFERENCES "user"(id)
);
`;

const createQuestionTable = async () => {
  try {
    await client.query(createQuestionTableQuery);
    console.log("Question table created successfully");
  } catch (error) {
    console.error("Error creating Question table:", error);
  }
};

// Function to save question data in the database
const saveQuestion = async (questionData) => {
  const {
    question_text,
    question_type,
    difficulty_level,
    categories,
    created_by,
    is_active,
    is_custom
  } = questionData;
  try {

    // Check if the question with the same text already exists
    const checkQuery = `
      SELECT * FROM question WHERE question_text = $1
    `;
    const checkResult = await client.query(checkQuery, [question_text]);
    if (checkResult.rows.length > 0) {
        return { error: 'Question with the same text already exists' };
    }

    const insertQuery = `
      INSERT INTO question (
        question_text,
        question_type,
        difficulty_level,
        categories,
        created_by,
        is_active,
        is_custom
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING *;
    `;
    const values = [
      question_text,
      question_type,
      difficulty_level,
      categories,
      created_by,
      is_active ?? true,
      is_custom ?? false
    ];
    const result = await client.query(insertQuery, values);
    console.log("Question data saved successfully");
    return result.rows[0]; // Return the inserted question data
  } catch (error) {
    console.error("Error saving Question data:", error);
    throw error;
  }
};

module.exports = { createQuestionTable, saveQuestion };

this is question controller
const { saveQuestion, createQuestionTable } = require('../models/question');
const { saveAnswer, createAnswersTable } = require('../models/answer');
const { client } = require('../db/index');

// Function to find category IDs by names
const findCategoryIdsByName = async (categoryNames) => {
  try {
    const categoryIds = [];

    for (const categoryName of categoryNames) {
      const result = await client.query('SELECT id FROM "category" WHERE category_name = $1', [categoryName]);
      if (result.rows.length > 0) {
        categoryIds.push(result.rows[0].id);
      } else {
        throw new Error(`Category '${categoryName}' not found`);
      }
    }

    return categoryIds;
  } catch (error) {
    throw error;
  }
};

const createQuestionAndAnswer = async (req, res) => {
  try {
    await createQuestionTable();
    await createAnswersTable();

    const { question_text, difficulty_level, category_names, options } = req.body;

    // Validate request data
    if (!question_text || !difficulty_level || !category_names || !options) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Find category IDs by names
    const categoryIds = await findCategoryIdsByName(category_names);

    // Check if the question already exists
    const existingQuestion = await client.query('SELECT id FROM question WHERE question_text = $1', [question_text]);
    let questionId;
    if (existingQuestion.rows.length > 0) {
      // If the question already exists, use its ID
      questionId = existingQuestion.rows[0].id;
    } else {
      // Save question if it does not exist
      const questionData = {
        question_text,
        question_type: 'MCQS', // Assuming multiple-choice questions
        difficulty_level,
        categories: categoryIds,
        created_by: req.user.id, // Assuming user ID is extracted from authentication middleware
        is_active: true,
        is_custom: false,
      };
      const newQuestion = await saveQuestion(questionData);
      questionId = newQuestion.id;
    }

    // Prepare answer data
    const answerData = {
      question_id: questionId,
      options, // Assuming options are provided in the request body
      created_by: req.user.id, // Assuming user ID is extracted from authentication middleware
    };

    // Save answer
    const answer = await saveAnswer(answerData);

    res.status(201).json({ question_id: questionId, answer });
  } catch (error) {
    console.error('Error creating question and answer:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};

// get ALL questions
const getAllQuestion = async (req, res) => {
    try {
      const getAllQuery = `
              SELECT * FROM question;
          `;
      const result = await client.query(getAllQuery);
  
      const questions = result.rows;
      res.status(200).json(questions);
    } catch (error) {
      console.error("Error fetching questions:", error);
      res.status(500).json({ error: "Could not fetch questions" });
    }
  };

// Delete question
const deleteQuestion = async (req, res) => {
  const { id } = req.params; // Access ID from req.params

  try {
    // Check if the question exists
    const checkQuery = `
      SELECT * FROM question 
      WHERE id = $1;
    `;
    const checkValues = [id];
    const checkResult = await client.query(checkQuery, checkValues);

    // If the question does not exist, return 404
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ error: "Question not found" });
    }

    // Use the ID to delete the question
    const deleteQuery = `
      DELETE FROM question 
      WHERE id = $1 
      RETURNING *;
    `;
    const values = [id];

    // **Cascading Delete with `ON DELETE CASCADE`**
    await client.query('BEGIN'); // Start transaction
    // Delete answers related to the question
    await client.query(
      'DELETE FROM answers WHERE question_id = $1',
      [id]
    );
    // Delete the question itself
    const result = await client.query(deleteQuery, values);
    await client.query('COMMIT'); // Commit transaction if successful

    const deletedQuestion = result.rows[0];
    res.status(200).json({ message: "Question deleted successfully", deletedQuestion });
  } catch (error) {
    console.error("Error deleting question:", error);
    await client.query('ROLLBACK'); // Rollback transaction on error
    res.status(500).json({ error: "Could not delete question" });
  }
};

  // Update Question
  const updateQuestion = async (req, res) => {
    const { id } = req.params;
    const { question_text, difficulty_level, category_names } = req.body;
  
    try {
      // Fetch the existing question data from the database
      const existingQuestion = await getQuestionById(id);
  
      if (!existingQuestion) {
        return res.status(404).json({ error: "Question not found" });
      }
  
      // Find category IDs for the updated category names
      const updatedCategoryIds = await findCategoryIdsByName(category_names);
  
      // Compare the updated fields with existing data
      if (
        question_text === existingQuestion.question_text &&
        difficulty_level === existingQuestion.difficulty_level &&
        JSON.stringify(updatedCategoryIds.sort()) === JSON.stringify(existingQuestion.categories.sort())
      ) {
        return res.status(400).json({ error: "No changes to update" });
      }
  
      const updateQuery = `
        UPDATE question 
        SET 
            question_text = $1,
            difficulty_level = $2,
            categories = $3,
            updated_date = CURRENT_TIMESTAMP
        WHERE id = $4
        RETURNING *;
      `;
      const values = [question_text, difficulty_level, updatedCategoryIds, id];
  
      const result = await client.query(updateQuery, values);
  
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Question not found" });
      }
  
      const updatedQuestion = result.rows[0];
      res.status(200).json(updatedQuestion);
    } catch (error) {
      console.error("Error updating question:", error);
      res.status(500).json({ error: "Could not update question" });
    }
  };
  
  // Get question by ID
const getQuestionById = async (req, res) => {
  const { id } = req.params;

  try {
    const query = `
      SELECT * FROM question
      WHERE id = $1;
    `;
    const result = await client.query(query, [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Question not found" });
    }

    const question = result.rows[0];
    res.status(200).json(question);
  } catch (error) {
    console.error("Error fetching question by ID:", error);
    res.status(500).json({ error: "Could not fetch question by ID" });
  }
};


module.exports = { createQuestionAndAnswer, getAllQuestion, deleteQuestion, updateQuestion, getQuestionById };

this is company model
const { client } = require("../db/index.js");

// Create Companies Table Query
const createCompaniesTableQuery = `
CREATE TABLE IF NOT EXISTS companies (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    website VARCHAR(100),
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INT,
    is_active BOOLEAN DEFAULT TRUE,
    stripe_customer_id VARCHAR(255),
    plan_id VARCHAR(255),
    FOREIGN KEY (created_by) REFERENCES "user"(id)
);
`;

// Create Companies Table
const createCompanyTable = async () => {
  try {
    await client.query(createCompaniesTableQuery);
    console.log("Companies table created successfully");
  } catch (error) {
    console.error("Error creating companies table:", error);
  }
};

// Function to save company data in the database
const saveCompany = async (companyData) => {
  const {
    name,
    website,
    created_by,
    is_active,
    stripe_customer_id,
    plan_id,
  } = companyData;
  try {
    const insertQuery = `
      INSERT INTO companies (
        name,
        website,
        created_by,
        is_active,
        stripe_customer_id,
        plan_id
      )
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING *;
    `;
    const values = [
      name,
      website || null,
      created_by,
      is_active ?? true,
      stripe_customer_id || null,
      plan_id || null,
    ];
    const result = await client.query(insertQuery, values);
    console.log("Company data saved successfully");
    return result.rows[0]; // Return the inserted company data
  } catch (error) {
    console.error("Error saving company data:", error);
    throw error;
  }
};

module.exports = { createCompanyTable, saveCompany };


this is company controller
const { createCompanyTable, saveCompany } = require("../models/company");
const { client } = require("../db/index.js");
const catchAsyncErrors = require("../middleware/catchAsyncErrors");

// Get all company
const getAllCompany = catchAsyncErrors(async (req, res, next) => {
  try {
    await createCompanyTable();

    const company = await client.query('SELECT * FROM "companies"');

    res.status(200).json(company.rows); // Return all company data in the response
  } catch (error) {
    console.error("Error fetching companies:", error.message);
    res.status(500).json({ error: "Error fetching companies" });
  }
});

// Get all companies of a specific user
const getAllCompaniesOfUser = catchAsyncErrors(async (req, res, next) => {
    try {
        // Extract user ID from req object (provided by verifyTokenAndExtractUserId middleware)
        const userId = req.user.id;

        // Fetch all companies associated with the user from the database
        const userCompanies = await client.query('SELECT * FROM companies WHERE created_by = $1', [userId]);

        // Return the list of user's companies in the response
        res.status(200).json(userCompanies.rows);
    } catch (error) {
        console.error("Error fetching user's companies:", error.message);
        res.status(500).json({ error: "Error fetching user's companies" });
    }
});

// create company
const createCompany = catchAsyncErrors(async (req, res, next) => {
    try {
         // Extract user ID from req object (provided by verifyTokenAndExtractUserId middleware)
         const userId = req.user.id;
         console.log(userId);

        // Extract company data from the request body
        const { name, website, isActive, stripeCustomerId, planId } = req.body;

        // Check if a company with the same name already exists
        const existingCompany = await client.query('SELECT * FROM companies WHERE name = $1', [name]);
        if (existingCompany.rows.length > 0) {
            return res.status(400).json({ error: "Company with this name already exists" });
        }

        // Create the company object with the extracted data
        const companyData = {
            name,
            website,
            created_by: userId, // Assign the user ID as the createdBy value
            isActive,
            stripeCustomerId,
            planId,
        };

        await createCompanyTable();

        // Save the company data in the database
        const newCompany = await saveCompany(companyData);

        // Send a success response with the newly created company data
        res.status(201).json({
            success: true,
            message: "Company created successfully",
            company: newCompany,
            userId: userId // Optionally, you can include the user ID in the response
        });
    } catch (error) {
        console.error("Error creating company:", error.message);
        res.status(500).json({ error: "Error creating company" });
    }
});

// Update company
const updateCompany = catchAsyncErrors(async (req, res, next) => {
    try {
      // Extract company ID from request parameters
      const companyId = req.params.id;
  
      // Extract updated company data from the request body
      const { name, website, isActive, stripeCustomerId, planId } = req.body;
  
      // Validate request data
      if (!name) {
        return res.status(400).json({ error: "Company name is required" });
      }
  
      // Check if the company exists
      const existingCompany = await client.query('SELECT * FROM companies WHERE id = $1', [companyId]);
      if (existingCompany.rows.length === 0) {
        return res.status(404).json({ error: "Company not found" });
      }

      // Check if the updated company name already exists
      const duplicateCompany = await client.query('SELECT * FROM companies WHERE name = $1 AND id != $2', [name, companyId]);
      if (duplicateCompany.rows.length > 0) {
        return res.status(400).json({ error: "Another company with this name already exists" });
      }
  
      // Update the company object with the extracted data
      const updatedCompanyData = {
        name,
        website: website || existingCompany.rows[0].website, // Use existing website if not provided in the request body
        isActive: isActive || existingCompany.rows[0].isActive, // Use existing isActive value if not provided in the request body
        stripeCustomerId: stripeCustomerId || existingCompany.rows[0].stripeCustomerId, // Use existing stripeCustomerId if not provided in the request body
        planId: planId || existingCompany.rows[0].planId // Use existing planId if not provided in the request body
      };
  
      // Update the company data in the database
      await client.query(
        'UPDATE companies SET name = $1, website = $2, is_active = $3, stripe_customer_id = $4, plan_id = $5 WHERE id = $6',
        [updatedCompanyData.name, updatedCompanyData.website, updatedCompanyData.isActive, updatedCompanyData.stripeCustomerId, updatedCompanyData.planId, companyId]
      );
  
      // Send a success response
      res.status(200).json({ success: true, message: "Company updated successfully" });
    } catch (error) {
      console.error("Error updating company:", error.message);
      res.status(500).json({ error: "Error updating company" });
    }
  });

  
 // Delete company
const deleteCompany = catchAsyncErrors(async (req, res, next) => {
    try {
      // Extract company ID from request parameters
      const companyId = req.params.id;
  
      // Check if the company exists
      const existingCompany = await client.query('SELECT * FROM companies WHERE id = $1', [companyId]);
      if (existingCompany.rows.length === 0) {
        return res.status(404).json({ error: "Company not found" });
      }
  
      // Begin a transaction
      await client.query('BEGIN');
  
      // Delete assessments associated with the company
      await client.query('DELETE FROM assessments WHERE company_id = $1', [companyId]);
  
      // Delete tests associated with the company
      await client.query('DELETE FROM tests WHERE company_id = $1', [companyId]);
  
      // Delete the company data from the database
      await client.query('DELETE FROM companies WHERE id = $1', [companyId]);
  
      // Commit the transaction
      await client.query('COMMIT');
  
      // Send a success response
      res.status(200).json({ success: true, message: "Company deleted successfully" });
    } catch (error) {
      // Rollback the transaction on error
      await client.query('ROLLBACK');
      console.error("Error deleting company:", error.message);
      res.status(500).json({ error: "Error deleting company" });
    }
  });
  

module.exports = { getAllCompany, createCompany, getAllCompaniesOfUser, updateCompany, deleteCompany };

this is test model
// models/test.js
const { client } = require("../db/index.js");

// Create Tests Table Query
const createTestsTableQuery = `
CREATE TABLE IF NOT EXISTS tests (
    id SERIAL PRIMARY KEY,
    test_name VARCHAR(100),
    test_description TEXT,
    categories INTEGER[],
    company_id INTEGER,
    created_by INTEGER,
    is_active BOOLEAN DEFAULT TRUE,
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (company_id) REFERENCES companies(id),
    FOREIGN KEY (created_by) REFERENCES "user"(id)
);
`;

// Create Tests Table
const createTestsTable = async () => {
  try {
    await client.query(createTestsTableQuery);
    console.log("Tests table created successfully");
  } catch (error) {
    console.error("Error creating tests table:", error);
  }
};

// Function to save test data in the database
const saveTest = async (testData) => {
  const {
    test_name,
    test_description,
    categories,
    company_id,
    created_by,
  } = testData;
  try {
    const insertQuery = `
      INSERT INTO tests (
        test_name,
        test_description,
        categories,
        company_id,
        created_by
      )
      VALUES ($1, $2, $3, $4, $5)
      RETURNING *;
    `;
    const values = [
      test_name,
      test_description,
      categories,
      company_id,
      created_by,
    ];
    const result = await client.query(insertQuery, values);
    console.log("Test data saved successfully");
    return result.rows[0]; // Return the inserted test data
  } catch (error) {
    console.error("Error saving test data:", error);
    throw error;
  }
};

module.exports = { createTestsTable, saveTest };

this is test controller
// controllers/testController.js
const { createTestsTable, saveTest } = require("../models/test");
const { client } = require("../db/index.js");
const catchAsyncErrors = require("../middleware/catchAsyncErrors");

// Get all tests
const getAllTests = catchAsyncErrors(async (req, res, next) => {
  try {
    await createTestsTable();

    const tests = await client.query('SELECT * FROM "tests"');

    res.status(200).json(tests.rows); // Return all test data in the response
  } catch (error) {
    console.error("Error fetching tests:", error.message);
    res.status(500).json({ error: "Error fetching tests" });
  }
});

// Function to find company ID by name
const findCompanyIdByName = async (companyName) => {
    try {
      const result = await client.query('SELECT id FROM "companies" WHERE name = $1', [companyName]);
      if (result.rows.length > 0) {
        return result.rows[0].id;
      } else {
        // Handle the case if a company with the provided name does not exist
        throw new Error(`Company '${companyName}' not found`);
      }
    } catch (error) {
      throw error;
    }
  };
  
  // Function to find category IDs by names
  const findCategoryIdsByName = async (categoryNames) => {
    try {
      const categoryIds = [];
  
      for (const categoryName of categoryNames) {
        const result = await client.query('SELECT id FROM "category" WHERE category_name = $1', [categoryName]);
        if (result.rows.length > 0) {
          categoryIds.push(result.rows[0].id);
        } else {
          // Handle the case if a category with the provided name does not exist
          throw new Error(`Category '${categoryName}' not found`);
          // return res.status(400).json({ error: `Category `${categoryName}` not found`});
        }
      }
  
      return categoryIds;
    } catch (error) {
      throw error;
    }
  };
  
// Update test by ID
const updateTestById = async (testId, updatedTest) => {
  try {
    // Update the test data in the database
    const query = `
      UPDATE tests 
      SET test_name = $1, test_description = $2, categories = $3, company_id = $4
      WHERE id = $5`;
    const values = [updatedTest.test_name, updatedTest.test_description, updatedTest.categories, updatedTest.company_id, testId];
    await client.query(query, values);
  } catch (error) {
    throw error;
  }
};

// Delete test by ID
const deleteTestById = async (testId) => {
  try {
    // Delete the test data from the database
    const query = 'DELETE FROM tests WHERE id = $1';
    const values = [testId];
    await client.query(query, values);
  } catch (error) {
    throw error;
  }
};

  // Create test
  const createTest = catchAsyncErrors(async (req, res, next) => {
    try {
        await createTestsTable();
      // Extract user ID from req object (provided by verifyTokenAndExtractUserId middleware)
      const userId = req.user.id;
  
      // Extract test data from the request body
      const { test_name, test_description, category_names, company_name } = req.body;
  
      // Validate request data
      if (!test_name || !category_names || !company_name) {
        return res.status(400).json({ error: "Missing required fields" });
      }
  
       // Check if a test with the same name already exists
       const existingTest = await client.query('SELECT * FROM tests WHERE test_name = $1', [test_name]);
       if (existingTest.rows.length > 0) {
           return res.status(400).json({ error: "Test with this name already exists" });
       }

      // Find company ID by name
      const companyId = await findCompanyIdByName(company_name);
  
      // Find category IDs by names
      const categoryIds = await findCategoryIdsByName(category_names);
  
      // Create the test object with the extracted data
      const testData = {
        test_name,
        test_description,
        categories: categoryIds,
        company_id: companyId,
        created_by: userId, // Assign the user ID as the createdBy value
      };
  
      // Save the test data in the database
      // Implement the saveTest function here
      const newTest = await saveTest(testData);
      // Send a success response with the newly created test data
      res.status(201).json({
        success: true,
        message: "Test created successfully",
        test: newTest,
        userId: userId // Optionally, you can include the user ID in the response
      });
    } catch (error) {
      console.error("Error creating test:", error.message);
      res.status(500).json({ error: "Error creating test" });
    }
  });
  
// Get test by ID
const getTestById = catchAsyncErrors(async (req, res, next) => {
  try {
    // Extract test ID from request parameters
    const testId = req.params.id;

    // Fetch the test data from the database
    const test = await client.query('SELECT * FROM tests WHERE id = $1', [testId]);

    if (test.rows.length === 0) {
      return res.status(404).json({ error: "Test not found" });
    }

    // Send the test data in the response
    res.status(200).json(test.rows[0]);
  } catch (error) {
    console.error("Error fetching test:", error.message);
    res.status(500).json({ error: "Error fetching test" });
  }
});

 // Edit test
const editTest = catchAsyncErrors(async (req, res, next) => {
  try {
    // Extract test ID from request parameters
    const testId = req.params.id;

    // Extract updated test data from the request body
    const { test_name, test_description, category_names, company_name } = req.body;

    // Validate request data
    if (!test_name || !category_names || !company_name) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    // Find company ID by name
    const companyId = await findCompanyIdByName(company_name);

    // Find category IDs by names
    const categoryIds = await findCategoryIdsByName(category_names);

    // Fetch the existing test data from the database
    const existingTest = await client.query('SELECT * FROM tests WHERE id = $1', [testId]);

    if (existingTest.rows.length === 0) {
      return res.status(404).json({ error: "Test not found" });
    }

    // Compare the updated fields with existing data
    if (
      test_name === existingTest.rows[0].test_name &&
      test_description === existingTest.rows[0].test_description &&
      JSON.stringify(categoryIds.sort()) === JSON.stringify(existingTest.rows[0].categories.sort()) &&
      companyId === existingTest.rows[0].company_id
    ) {
      return res.status(400).json({ error: "No changes to update" });
    }

    // Update the test object with the extracted data
    const updatedTest = {
      test_name,
      test_description,
      categories: categoryIds,
      company_id: companyId
    };

    await updateTestById(testId, updatedTest);

    // Send a success response with the updated test data
    res.status(200).json({
      success: true,
      message: "Test updated successfully",
      test: updatedTest
    });
  } catch (error) {
    console.error("Error updating test:", error.message);
    res.status(500).json({ error: "Error updating test" });
  }
});

// Delete test
const deleteTest = catchAsyncErrors(async (req, res, next) => {
  try {
    // Extract test ID from request parameters
    const testId = req.params.id;

    // Check if the test exists
    const existingTest = await client.query('SELECT * FROM tests WHERE id = $1', [testId]);
    if (existingTest.rows.length === 0) {
      return res.status(404).json({ error: "Test not found" });
    }

    // Delete the test data from the database
    await deleteTestById(testId);

    // Send a success response
    res.status(200).json({
      success: true,
      message: "Test deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting test:", error.message);
    res.status(500).json({ error: "Error deleting test" });
  }
});

  
  module.exports = { createTest, editTest, deleteTest, getAllTests, getTestById };

this is assessment model
// models/assessment.js
const { client } = require("../db/index.js");

// Create Assessments Table Query
const createAssessmentsTableQuery = `
CREATE TABLE IF NOT EXISTS assessments (
    id SERIAL PRIMARY KEY,
    assessment_name VARCHAR(100),
    company_id INTEGER,
    tests INTEGER[],
    shareableLink VARCHAR(255),
    uniquelink VARCHAR(255),
    created_by INTEGER,
    is_active BOOLEAN DEFAULT TRUE,
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (company_id) REFERENCES companies(id),
    FOREIGN KEY (created_by) REFERENCES "user"(id)
);
`;

// Create Assessments Table
const createAssessmentsTable = async () => {
  try {
    await client.query(createAssessmentsTableQuery);
    console.log("Assessments table created successfully");
  } catch (error) {
    console.error("Error creating Assessments table:", error);
  }
};

// Function to save assessment data in the database
const saveAssessment = async (assessmentData) => {
  const {
    assessment_name,
    company_id,
    tests,
    shareableLink,
    uniquelink,
    created_by,
  } = assessmentData;
  try {

   // Check if a link already exists
   const checkLinkQuery = `
   SELECT * FROM assessments WHERE shareableLink = $1
 `;
 const checkLinkResult = await client.query(checkLinkQuery, [shareableLink]);
 if (checkLinkResult.rows.length > 0) {
   return { error: 'Assessment link already exists. Please generate a unique link.' };
 }

  // Check if a user with the same email already exists
  const existingAssessment = await client.query(
    'SELECT * FROM "assessments" WHERE assessment_name = $1',
    [assessment_name]
  );
  if (existingAssessment.rows.length > 0) {
    return {error:"Assessment with this name already exists"};
  }

    const insertQuery = `
      INSERT INTO assessments (
        assessment_name,
        company_id,
        tests,
        shareableLink,
        uniquelink,
        created_by
      )
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING *;
    `;
    const values = [
      assessment_name,
      company_id,
      tests,
      shareableLink,
      uniquelink,
      created_by,
    ];
    const result = await client.query(insertQuery, values);
    console.log("Assessment data saved successfully");
    return result.rows[0]; // Return the inserted assessment data
  } catch (error) {
    console.error("Error saving assessment data:", error);
    throw error;
  }
};

module.exports = { createAssessmentsTable, saveAssessment };

this is assessment controller
const { createAssessmentsTable, saveAssessment } = require("../models/assessment");
const { client } = require("../db/index.js");
const catchAsyncErrors = require("../middleware/catchAsyncErrors");

// Function to generate a unique random string
const generateUniqueLink = async () => {
  let link;
  let shareableLink; // Define shareableLink outside the loop
  let checkLinkResult;
  do {
    link = Math.random().toString(36).substring(2, 15);
    shareableLink = `http://localhost:3000/api/Assessments/assessment?uniqueLink=${link}`; // Use link instead of undefined variable shareableLink
    const checkLinkQuery = `
      SELECT * FROM assessments WHERE uniquelink = $1
    `;
    checkLinkResult = await client.query(checkLinkQuery, [link]);
  } while (checkLinkResult.rows.length > 0);
  return { link, shareableLink }; // Return shareableLink after the loop
};

  
// Function to find company ID by name
const findCompanyIdByName = async (companyName) => {
    try {
      const result = await client.query('SELECT id FROM "companies" WHERE name = $1', [companyName]);
      if (result.rows.length > 0) {
        return result.rows[0].id;
      } else {
        // Handle the case if a company with the provided name does not exist
        throw new Error(`Company '${companyName}' not found`);
      }
    } catch (error) {
      throw error;
    }
  };

  // Function to find category IDs by names
  const findTestIdsByName = async (tests) => {
    try {
      const testIds = [];
  
      for (const testName of tests) {
        const result = await client.query('SELECT id FROM "tests" WHERE test_name = $1', [testName]);
        if (result.rows.length > 0) {
            testIds.push(result.rows[0].id);
        } else {
          // Handle the case if a category with the provided name does not exist
          throw new Error(`Test '${testName}' not found`);
          // return res.status(400).json({ error: `Category `${categoryName}` not found`});
        }
      }
      return testIds;
    } catch (error) {
      throw error;
    }
  };

const getAssessmentByLink = catchAsyncErrors(async (req, res) => {
    try {
      const { uniqueLink } = req.params;
      const query = `
        SELECT * FROM assessments
        WHERE uniquelink = $1`;
      const values = [uniqueLink];
      const result = await client.query(query, values);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Assessment not found" });
      }
      res.status(200).json(result.rows[0]);
    } catch (error) {
      console.error("Error fetching Assessment:", error);
      res.status(500).json({ error: "Internal Server Error" });
    }
  });

  // Create Assessment
  const createAssessment = catchAsyncErrors(async (req, res, next) => {
    try {
      await createAssessmentsTable();
  
      const { assessment_name, company_name, tests } = req.body;
  
     // Validate request data
    if (!assessment_name || !company_name || !tests) {
        return res.status(400).json({ error: 'Missing required fields' });
      }

      // Find company ID by name
    const companyId = await findCompanyIdByName(company_name);
  
    // Find test IDs by names
    const testIds = await findTestIdsByName(tests);

      // Generate a unique link
      const link = await generateUniqueLink();
      console.log(link.link, link.shareableLink + " from generateuniquelink() function in create assessments");
  
      // Create the assessment object with the extracted data
      const assessmentData = {
        assessment_name,
        company_id: companyId, // Can be null if company_name is not provided
        tests:testIds,
        shareableLink:link.shareableLink,
        uniquelink:link.link,
        created_by: req.user.id,
      }
          // Save assessment data in the database
    const assessment = await saveAssessment(assessmentData);
    res.status(201).json({ assessment });
  } catch (error) {
    console.error("Error creating Assessment:", error.message);
      res.status(500).json({ error: "Error creating Assessment" });
  }
});

// Get all assessments
const getAllAssessments = catchAsyncErrors(async (req, res, next) => {
  try {
      const assessments = await client.query('SELECT * FROM assessments');
      res.status(200).json({ assessments: assessments.rows });
  } catch (error) {
      console.error("Error fetching assessments:", error.message);
      res.status(500).json({ error: "Error fetching assessments" });
  }
});

// Get all user assessments
const getAllUserAssessments = catchAsyncErrors(async (req, res, next) => {
  try {
      const userId = req.user.id;
      const userAssessments = await client.query('SELECT * FROM assessments WHERE created_by = $1', [userId]);
      res.status(200).json({ assessments: userAssessments.rows });
  } catch (error) {
      console.error("Error fetching user's assessments:", error.message);
      res.status(500).json({ error: "Error fetching user's assessments" });
  }
});

// Update Assessment
const updateAssessment = catchAsyncErrors(async (req, res, next) => {
  try {
      const { id } = req.params;
      const { assessment_name, company_name, tests } = req.body;

      // Validate request data
      if (!assessment_name || !company_name || !tests) {
          return res.status(400).json({ error: 'Missing required fields' });
      }

      // Find company ID by name
      const companyId = await findCompanyIdByName(company_name);

      // Find test IDs by names
      const testIds = await findTestIdsByName(tests);

      // Update assessment data in the database
      const query = `
          UPDATE assessments 
          SET assessment_name = $1, company_id = $2, tests = $3
          WHERE id = $4`;
      const values = [assessment_name, companyId, testIds, id];
      await client.query(query, values);

      res.status(200).json({ message: 'Assessment updated successfully' });
  } catch (error) {
      console.error("Error updating Assessment:", error.message);
      res.status(500).json({ error: "Error updating Assessment" });
  }
});

// Delete Assessment
const deleteAssessment = catchAsyncErrors(async (req, res, next) => {
  try {
      const { id } = req.params;

      // Delete assessment from the database
      const query = 'DELETE FROM assessments WHERE id = $1';
      const values = [id];
      await client.query(query, values);

      res.status(200).json({ message: 'Assessment deleted successfully' });
  } catch (error) {
      console.error("Error deleting Assessment:", error.message);
      res.status(500).json({ error: "Error deleting Assessment" });
  }
});
this is answer model
// models/answer.js
const { client } = require("../db/index.js");

// Create Answers Table Query
const createAnswersTableQuery = `
CREATE TABLE IF NOT EXISTS answers (
    id SERIAL PRIMARY KEY,
    question_id INTEGER,
    options JSONB[],
    created_by INT,
    is_active BOOLEAN DEFAULT TRUE,
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (created_by) REFERENCES "user"(id),
    FOREIGN KEY (question_id) REFERENCES "question"(id)
);
`;

// Create Answers Table
const createAnswersTable = async () => {
  try {
    await client.query(createAnswersTableQuery);
    console.log("Answers table created successfully");
  } catch (error) {
    console.error("Error creating answers table:", error);
  }
};

// Function to save answer data in the database
const saveAnswer = async (answerData) => {
  const {
    question_id,
    options,
    created_by,
  } = answerData;
  try {

// Check if the question with the same text already exists
const checkQuery = `
SELECT * FROM answers WHERE question_id = $1
`;
const checkResult = await client.query(checkQuery, [question_id]);
if (checkResult.rows.length > 0) {
  return { error: 'Answer for this question already exists' };
}

    const insertQuery = `
      INSERT INTO answers (
        question_id,
        options,
        created_by
      )
      VALUES ($1, $2, $3)
      RETURNING *;
    `;
    const values = [
      question_id,
      options,
      created_by,
    ];
    const result = await client.query(insertQuery, values);
    console.log("Answer data saved successfully");
    return result.rows[0]; // Return the inserted answer data
  } catch (error) {
    console.error("Error saving answer data:", error);
    throw error;
  }
};

module.exports = { createAnswersTable, saveAnswer };

  module.exports = { createAssessment, getAllAssessments, getAssessmentByLink, getAllUserAssessments, updateAssessment, deleteAssessment };

i want you to create result model,controller and router. heres the feild i want in result table 
id,candidate_id(which will be refrenced to candidate table),test_id(which will be refrenced to test table),questions which will be Array of objectsâ€¨{question_id: 1(refrenced to question table), answer_id: 1(refrenced to answer table), is_correct: 0(will notify that the question which is being answered by user is correct or incorrect)},score(which will update after every question will be answered),assessment_id(which will refrenced to assessment table, an assessment contain multiple of tests),started_at(which will default timestamp like created_at),completed_at(which will be update after every question),updated_at(which will be updated at after every question).

so now i will define you the whole scenerio which i want you to be create,
after assessment creation user will be provided a shareable link from which anyone can click on that link and will redirect to start tests page, an assessment contain multiple of tests so for example there are 3 tests of seo,coding and marketing. and for example candidate clicks on seo test and start the quiz then after clicking on the button start the quiz a result model will be created with that candidate_id , test_id and assessment_id and score will be null. and after every question that is answered and the next button is clicked then that result model will be updated and you should make a function on answer controller which takes the selected option, question_id and answer_id and then will modify that result model and in questions array a question_id,answer_id and is_correct will be added to that array if answer is correct then 1 and if answer will wrong then 0 should be there. for example each test contain 10 question after that 10 question and submit the test button will click the result model should be modify with the feilds above. after every question answered and result model modify then completed_at and updated_at will be modify and so create the functions in result controller with all validations and required function i have provided the whole code for my project above you can look at that also. and also create a function in answer controller which takes question_id,answer_id and option and will verify the answer and for that updated the score in that result model. and i am confuse that in answer controller function how will you check that which result should be updated so please created that logic also.
create result model,controller and router and require functions in answer controller.
now i have understand you every scenerio please create that function and code good. 